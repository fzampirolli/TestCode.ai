
FEEDBACK DA AVALIAÃ‡ÃƒO - OOP Assessment - P1
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Aluno: StudentTwo SurnameTwo (fzampirolli3)
Data: 2025-09-13 21:08:31
Nota Final (de 1 tentativa): 98.00 pontos
Total de Chamadas Ã  API: 1

## AnÃ¡lise da QuestÃ£o 1 - Singleton Pattern

### CÃ³digo Submetido:
```python
class CentralNotificacoes:
    _instancia = None

    def __new__(cls):
        if cls._instancia == None:
            cls._instancia = super().__new__(cls)
            cls._instancia.msg = ["Nova ConexÃ£o", "Mensagem recebida"]
            print("Central iniciada")
        else:
            print("Central jÃ¡ ativa")
        return cls._instancia

    def adicionar(self, msg):
        self.msg.append(msg)
        print(f"Nova notificaÃ§Ã£o: {msg}")

    def listar(self):
        print("NotificaÃ§Ãµes:")
        for msg in self.msg:
            print(f"{msg}")

msg = input()
comando = input()

app = CentralNotificacoes()

if comando == "adicionar":
    app.adicionar(msg)
elif comando == "listar":
    app.adicionar(msg)
    app.listar()
elif comando == "nova_instancia":
    app = CentralNotificacoes()
```

### AvaliaÃ§Ã£o Conforme Rubrica:

1. **InstÃ¢ncia Ãšnica**:
   - âœ… CORRETO: O cÃ³digo utiliza um atributo estÃ¡tico `_instancia` para armazenar a instÃ¢ncia Ãºnica
e verifica se ela jÃ¡ existe antes de criar uma nova.

2. **MÃ©todo de Acesso**:
   - âœ… CORRETO: O mÃ©todo `__new__` atua como um mÃ©todo de acesso estÃ¡tico que retorna a instÃ¢ncia
Ãºnica, criando-a apenas se nÃ£o existir.

3. **Construtor Privado/Protegido**:
   - âœ… CORRETO: O construtor (`__new__`) Ã© controlado e impede a criaÃ§Ã£o de mÃºltiplas instÃ¢ncias
diretamente.

4. **ExecuÃ§Ã£o Correta**:
   - âœ… CORRETO: O cÃ³digo executa sem erros de sintaxe e a lÃ³gica Ã© coerente.

### PontuaÃ§Ã£o:
- Todos os critÃ©rios obrigatÃ³rios foram atendidos corretamente.
- Nota: 25/25

### Feedback:
O cÃ³digo implementa corretamente o padrÃ£o Singleton. A classe `CentralNotificacoes` garante que
apenas uma instÃ¢ncia seja criada, e o mÃ©todo `__new__` controla essa criaÃ§Ã£o. A execuÃ§Ã£o do cÃ³digo
tambÃ©m ocorre sem erros de sintaxe. O Ãºnico ponto a considerar Ã© que, embora o cÃ³digo funcione
corretamente em um ambiente single-threaded, em um ambiente multi-threaded, ele poderia falhar
devido Ã  falta de sincronizaÃ§Ã£o. Para melhorar, poderia ser implementada uma trava (lock) para
garantir a seguranÃ§a em ambientes concorrentes.

==================================================
ğŸ“Š CORREÃ‡ÃƒO AUTOMÃTICA â€” Q1: 25/25
==================================================
QUESTAO_Q1: 25/25 - ImplementaÃ§Ã£o perfeita do padrÃ£o Singleton.

## AnÃ¡lise da QuestÃ£o 2 - Inheritance and Composition

### CÃ³digo Submetido:
```python
from abc import ABC, abstractmethod

class Disciplina:
    def __init__(self, nome):
        self.nome = nome

class Curso(ABC):
    def __init__(self, nome, duracao: int):
        self.nome = nome
        self.duracao = duracao
        self.disciplinas = []

        if self.duracao < 0:
            raise ValueError("DuraÃ§Ã£o invÃ¡lida")

    @abstractmethod
    def calcular_carga_horaria(self):
        pass

class Graduacao(Curso):
    def __init__(self, nome, duracao: int):
        super().__init__(nome, duracao)

    def calcular_carga_horaria(self):
        carga = self.duracao * 200
        print(f"Carga horÃ¡ria: {carga}")

    def adicionar_disciplina(self, disciplina: Disciplina):
        self.disciplinas.append(disciplina.nome)

class PosGraduacao(Curso):
    def __init__(self, nome, duracao: int):
        super().__init__(nome, duracao)

    def calcular_carga_horaria(self):
        carga = self.duracao * 134
        print(f"Carga horÃ¡ria: {carga}")

    def adicionar_disciplina(self, disciplina: Disciplina):
        self.disciplinas.append(disciplina.nome)

nome, duracao, tipo = input().split("; ")
duracao_int = int(duracao)

if tipo == "graduacao":
    curso = Graduacao(nome, duracao_int)
    print("GraduaÃ§Ã£o criada")
elif tipo == "pos":
    curso = PosGraduacao(nome, duracao_int)
    print("PÃ³s-graduaÃ§Ã£o criada")

curso.calcular_carga_horaria()

entradas_d = input()
disc = Disciplina(entradas_d)
curso.adicionar_disciplina(disc)
print(f"Disciplinas: {curso.disciplinas}")
```

### AvaliaÃ§Ã£o Conforme Rubrica:

1. **Classe Abstrata Base**:
   - âœ… CORRETO: A classe `Curso` Ã© abstrata e contÃ©m atributos bÃ¡sicos como `nome` e `duracao`.

2. **MÃ©todo Abstrato**:
   - âœ… CORRETO: O mÃ©todo `calcular_carga_horaria` Ã© abstrato e foi implementado corretamente nas
subclasses.

3. **HeranÃ§a Correta**:
   - âœ… CORRETO: As subclasses `Graduacao` e `PosGraduacao` herdam de `Curso` e implementam o mÃ©todo
abstrato.

4. **Classe Auxiliar**:
   - âœ… CORRETO: A classe `Disciplina` Ã© uma classe auxiliar bem definida com um atributo `nome`.

5. **ComposiÃ§Ã£o/AgregaÃ§Ã£o**:
   - âš ï¸ PARCIALMENTE CORRETO: A classe `Curso` contÃ©m uma lista de disciplinas, mas armazena apenas
o nome da disciplina, nÃ£o o objeto `Disciplina` completo.

6. **Tratamento de ExceÃ§Ãµes**:
   - âœ… CORRETO: O construtor de `Curso` verifica se `duracao` Ã© negativo e lanÃ§a um `ValueError`
apropriado.

7. **ExecuÃ§Ã£o Correta**:
   - âœ… CORRETO: O cÃ³digo executa sem erros de sintaxe e a lÃ³gica Ã© coerente.

### PontuaÃ§Ã£o:
- Total: 73/75
  - Falta apenas na composiÃ§Ã£o/agregaÃ§Ã£o, pois armazena apenas o nome da disciplina.

### Feedback:
O cÃ³digo implementa corretamente a maioria dos critÃ©rios exigidos. A classe abstrata `Curso` e suas
subclasses estÃ£o bem estruturadas, e o tratamento de exceÃ§Ãµes Ã© adequado. No entanto, a
composiÃ§Ã£o/agregaÃ§Ã£o poderia ser melhorada armazenando o objeto `Disciplina` completo em vez de
apenas seu nome. Isso permitiria uma representaÃ§Ã£o mais rica e flexÃ­vel das disciplinas associadas a
um curso.

==================================================
ğŸ“Š CORREÃ‡ÃƒO AUTOMÃTICA â€” Q2: 73/75
==================================================
QUESTAO_Q2: 73/75 - Excelente implementaÃ§Ã£o, com pequena falha na composiÃ§Ã£o/agregaÃ§Ã£o.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Este feedback foi gerado automaticamente por IA e pode
necessitar de revisÃ£o pelo professor.
