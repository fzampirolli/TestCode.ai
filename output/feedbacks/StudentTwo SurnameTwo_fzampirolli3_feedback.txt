
FEEDBACK DA AVALIAÇÃO - OOP Assessment - P1
═══════════════════════════════════════════════════════════
Aluno: StudentTwo SurnameTwo (fzampirolli3)
Data: 2025-09-13 21:08:31
Nota Final (de 1 tentativa): 98.00 pontos
Total de Chamadas à API: 1

## Análise da Questão 1 - Singleton Pattern

### Código Submetido:
```python
class CentralNotificacoes:
    _instancia = None

    def __new__(cls):
        if cls._instancia == None:
            cls._instancia = super().__new__(cls)
            cls._instancia.msg = ["Nova Conexão", "Mensagem recebida"]
            print("Central iniciada")
        else:
            print("Central já ativa")
        return cls._instancia

    def adicionar(self, msg):
        self.msg.append(msg)
        print(f"Nova notificação: {msg}")

    def listar(self):
        print("Notificações:")
        for msg in self.msg:
            print(f"{msg}")

msg = input()
comando = input()

app = CentralNotificacoes()

if comando == "adicionar":
    app.adicionar(msg)
elif comando == "listar":
    app.adicionar(msg)
    app.listar()
elif comando == "nova_instancia":
    app = CentralNotificacoes()
```

### Avaliação Conforme Rubrica:

1. **Instância Única**:
   - ✅ CORRETO: O código utiliza um atributo estático `_instancia` para armazenar a instância única
e verifica se ela já existe antes de criar uma nova.

2. **Método de Acesso**:
   - ✅ CORRETO: O método `__new__` atua como um método de acesso estático que retorna a instância
única, criando-a apenas se não existir.

3. **Construtor Privado/Protegido**:
   - ✅ CORRETO: O construtor (`__new__`) é controlado e impede a criação de múltiplas instâncias
diretamente.

4. **Execução Correta**:
   - ✅ CORRETO: O código executa sem erros de sintaxe e a lógica é coerente.

### Pontuação:
- Todos os critérios obrigatórios foram atendidos corretamente.
- Nota: 25/25

### Feedback:
O código implementa corretamente o padrão Singleton. A classe `CentralNotificacoes` garante que
apenas uma instância seja criada, e o método `__new__` controla essa criação. A execução do código
também ocorre sem erros de sintaxe. O único ponto a considerar é que, embora o código funcione
corretamente em um ambiente single-threaded, em um ambiente multi-threaded, ele poderia falhar
devido à falta de sincronização. Para melhorar, poderia ser implementada uma trava (lock) para
garantir a segurança em ambientes concorrentes.

==================================================
📊 CORREÇÃO AUTOMÁTICA — Q1: 25/25
==================================================
QUESTAO_Q1: 25/25 - Implementação perfeita do padrão Singleton.

## Análise da Questão 2 - Inheritance and Composition

### Código Submetido:
```python
from abc import ABC, abstractmethod

class Disciplina:
    def __init__(self, nome):
        self.nome = nome

class Curso(ABC):
    def __init__(self, nome, duracao: int):
        self.nome = nome
        self.duracao = duracao
        self.disciplinas = []

        if self.duracao < 0:
            raise ValueError("Duração inválida")

    @abstractmethod
    def calcular_carga_horaria(self):
        pass

class Graduacao(Curso):
    def __init__(self, nome, duracao: int):
        super().__init__(nome, duracao)

    def calcular_carga_horaria(self):
        carga = self.duracao * 200
        print(f"Carga horária: {carga}")

    def adicionar_disciplina(self, disciplina: Disciplina):
        self.disciplinas.append(disciplina.nome)

class PosGraduacao(Curso):
    def __init__(self, nome, duracao: int):
        super().__init__(nome, duracao)

    def calcular_carga_horaria(self):
        carga = self.duracao * 134
        print(f"Carga horária: {carga}")

    def adicionar_disciplina(self, disciplina: Disciplina):
        self.disciplinas.append(disciplina.nome)

nome, duracao, tipo = input().split("; ")
duracao_int = int(duracao)

if tipo == "graduacao":
    curso = Graduacao(nome, duracao_int)
    print("Graduação criada")
elif tipo == "pos":
    curso = PosGraduacao(nome, duracao_int)
    print("Pós-graduação criada")

curso.calcular_carga_horaria()

entradas_d = input()
disc = Disciplina(entradas_d)
curso.adicionar_disciplina(disc)
print(f"Disciplinas: {curso.disciplinas}")
```

### Avaliação Conforme Rubrica:

1. **Classe Abstrata Base**:
   - ✅ CORRETO: A classe `Curso` é abstrata e contém atributos básicos como `nome` e `duracao`.

2. **Método Abstrato**:
   - ✅ CORRETO: O método `calcular_carga_horaria` é abstrato e foi implementado corretamente nas
subclasses.

3. **Herança Correta**:
   - ✅ CORRETO: As subclasses `Graduacao` e `PosGraduacao` herdam de `Curso` e implementam o método
abstrato.

4. **Classe Auxiliar**:
   - ✅ CORRETO: A classe `Disciplina` é uma classe auxiliar bem definida com um atributo `nome`.

5. **Composição/Agregação**:
   - ⚠️ PARCIALMENTE CORRETO: A classe `Curso` contém uma lista de disciplinas, mas armazena apenas
o nome da disciplina, não o objeto `Disciplina` completo.

6. **Tratamento de Exceções**:
   - ✅ CORRETO: O construtor de `Curso` verifica se `duracao` é negativo e lança um `ValueError`
apropriado.

7. **Execução Correta**:
   - ✅ CORRETO: O código executa sem erros de sintaxe e a lógica é coerente.

### Pontuação:
- Total: 73/75
  - Falta apenas na composição/agregação, pois armazena apenas o nome da disciplina.

### Feedback:
O código implementa corretamente a maioria dos critérios exigidos. A classe abstrata `Curso` e suas
subclasses estão bem estruturadas, e o tratamento de exceções é adequado. No entanto, a
composição/agregação poderia ser melhorada armazenando o objeto `Disciplina` completo em vez de
apenas seu nome. Isso permitiria uma representação mais rica e flexível das disciplinas associadas a
um curso.

==================================================
📊 CORREÇÃO AUTOMÁTICA — Q2: 73/75
==================================================
QUESTAO_Q2: 73/75 - Excelente implementação, com pequena falha na composição/agregação.

═══════════════════════════════════════════════════════════
Este feedback foi gerado automaticamente por IA e pode
necessitar de revisão pelo professor.
