
FEEDBACK DA AVALIAÃ‡ÃƒO - Prova 1 - POO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Estudante: StudentThree SurnameThree (fzampirolli3)
Data: 2025-09-16 18:56:28
Nota Final (HIGHEST de 3 tentativas): 95.00 pontos
Total de Chamadas Ã  API: 3

ObservaÃ§Ã£o: A 'Nota Final' Ã© o resultado do critÃ©rio 'HIGHEST' aplicado a 3 tentativas. O feedback
detalhado e as notas por questÃ£o abaixo referem-se especificamente Ã  tentativa com a MAIOR nota.

## AnÃ¡lise da QuestÃ£o 1 - PadrÃ£o Singleton

### CÃ³digo Submetido
```python
import sys

class SomSistema:
    _instancia = None

    def __new__(cls):
        if cls._instancia is None:
            cls._instancia = super().__new__(cls)
            cls._instancia.somp = None
            print("Gerenciador de som criado")
        else:
            print("Gerenciador jÃ¡ existente")
        return cls._instancia

    def tocar_som(self, som):
        self.somp = som
        print(f"Tocando som: {som}")

    def som_atual(self):
        print(f"Som atual: {self.somp}")

sistema = SomSistema()
entrada = input().strip()
comando = input().strip()

if comando == "tocar_som":
    sistema.tocar_som(entrada)
elif comando == "som_atual":
    sistema.som_atual()
elif comando == "nova_instancia":
    sistema = SomSistema()
else:
    print("Comando invÃ¡lido")
    exit()
```

### AvaliaÃ§Ã£o Conforme Rubrica

1. **InstÃ¢ncia Ãšnica**:
   - âœ… CORRETO: O cÃ³digo implementa o padrÃ£o Singleton corretamente, garantindo que apenas uma
instÃ¢ncia de `SomSistema` seja criada. O atributo `_instancia` Ã© estÃ¡tico e privado, e hÃ¡ uma
verificaÃ§Ã£o antes de criar uma nova instÃ¢ncia.

2. **MÃ©todo de Acesso**:
   - âœ… CORRETO: O mÃ©todo `__new__` atua como um mÃ©todo de acesso controlado, retornando sempre a
mesma instÃ¢ncia. Embora nÃ£o seja um mÃ©todo estÃ¡tico nomeado como `getInstance`, sua funcionalidade Ã©
equivalente.

3. **Construtor Privado/Protegido**:
   - âœ… CORRETO: O construtor (`__new__`) Ã© controlado, impedindo a criaÃ§Ã£o direta de mÃºltiplas
instÃ¢ncias. Embora Python nÃ£o tenha construtores privados no sentido tradicional, o uso de `__new__`
para controlar a instanciaÃ§Ã£o Ã© uma prÃ¡tica comum e eficaz.

4. **ExecuÃ§Ã£o Correta**:
   - âœ… CORRETO: O cÃ³digo executa sem erros de sintaxe aparentes e a lÃ³gica Ã© coerente com o padrÃ£o
Singleton.

### PontuaÃ§Ã£o
- Todos os critÃ©rios obrigatÃ³rios foram atendidos corretamente.
- Nota: **25/25**

### Feedback
O cÃ³digo implementa corretamente o padrÃ£o Singleton, garantindo uma instÃ¢ncia Ãºnica e fornecendo um
mÃ©todo controlado de acesso a essa instÃ¢ncia. A lÃ³gica Ã© coerente e o cÃ³digo executa sem erros de
sintaxe. O uso de `__new__` para controlar a instanciaÃ§Ã£o Ã© apropriado para Python.

==================================================
ğŸ“Š CORREÃ‡ÃƒO AUTOMÃTICA â€” Q1: 25 pontos (mÃ¡x:25)
==================================================
QUESTAO_Q1: 25/25 - ImplementaÃ§Ã£o perfeita do padrÃ£o Singleton.

## AnÃ¡lise da QuestÃ£o 2 - HeranÃ§a, ComposiÃ§Ã£o e ExceÃ§Ãµes

### CÃ³digo Submetido
```python
import sys
from abc import ABC, abstractmethod

class Funcionario(ABC):

    def __init__(self, nome, salario):
        self.nome = nome
        self.salario = salario
        self.listaprojetos = []

        if salario < 0:
            raise ValueError("SalÃ¡rio invÃ¡lido")

    @abstractmethod
    def calcular_bonus(self):
        pass

    def adicionar_projeto(self, projeto):
        self.listaprojetos.append(projeto)


class Desenvolvedor(Funcionario):

    def calcular_bonus(self):
        return self.salario * 0.11

class Gerente(Funcionario):

    def calcular_bonus(self):
        return self.salario * 0.21

class Projeto:

    def __init__(self, nome):
        self.nome = nome

entrada = input().split("; ")
nome = entrada[0].strip()
salario = float(entrada[1].strip()) # Corrigido para float
tipo = entrada[2].strip().lower() # Corrigido para chamar o mÃ©todo

if tipo == "gerente":
    funcionario = Gerente(nome, salario)
elif tipo == "desenvolvedor":
    funcionario = Desenvolvedor(nome, salario)

linha_projetos = input().strip()
if linha_projetos:
    nomes = linha_projetos.split("; ")
    for nome_eq in nomes:
        projeto = Projeto(nome_eq.strip())
        funcionario.adicionar_projeto(projeto) # Adicionado projeto ao funcionÃ¡rio
```

### AvaliaÃ§Ã£o Conforme Rubrica

1. **Classe Abstrata Base**:
   - âœ… CORRETO: `Funcionario` Ã© uma classe abstrata bem definida usando `ABC` e contÃ©m atributos
bÃ¡sicos (`nome`, `salario`, `listaprojetos`).

2. **MÃ©todo Abstrato**:
   - âœ… CORRETO: `calcular_bonus` Ã© um mÃ©todo abstrato definido na classe base e implementado
corretamente nas subclasses `Desenvolvedor` e `Gerente`.

3. **HeranÃ§a Correta**:
   - âœ… CORRETO: As subclasses `Desenvolvedor` e `Gerente` herdam de `Funcionario` e implementam o
mÃ©todo abstrato `calcular_bonus`.

4. **Classe Auxiliar**:
   - âœ… CORRETO: `Projeto` Ã© uma classe auxiliar bem definida com um atributo `nome`.

5. **ComposiÃ§Ã£o/AgregaÃ§Ã£o**:
   - âœ… CORRETO: `Funcionario` contÃ©m uma lista de `Projeto` (`listaprojetos`), e hÃ¡ um mÃ©todo
`adicionar_projeto` para adicionar projetos a essa lista.

6. **Tratamento de ExceÃ§Ãµes**:
   - âœ… CORRETO: O construtor de `Funcionario` verifica se `salario` Ã© negativo e lanÃ§a um
`ValueError` se verdadeiro.

7. **ExecuÃ§Ã£o Correta**:
   - âš ï¸ PARCIALMENTE CORRETO: Houve necessidade de algumas correÃ§Ãµes (ex.: converter `salario` para
`float`, chamar `lower()` corretamente, adicionar projeto ao funcionÃ¡rio). ApÃ³s essas correÃ§Ãµes, o
cÃ³digo executa corretamente.

### PontuaÃ§Ã£o
- Total de pontos possÃ­veis: 75
- CritÃ©rios corretos: 6 (todos exceto execuÃ§Ã£o perfeita sem necessidade de correÃ§Ãµes)
- Nota: **70/75** (considerando as correÃ§Ãµes feitas)

### Feedback
O cÃ³digo implementa corretamente os conceitos de heranÃ§a, composiÃ§Ã£o e tratamento de exceÃ§Ãµes. A
classe abstrata `Funcionario` Ã© bem definida, e as subclasses implementam o mÃ©todo abstrato
corretamente. A classe `Projeto` serve como uma classe auxiliar adequada para composiÃ§Ã£o. O
tratamento de exceÃ§Ãµes no construtor de `Funcionario` Ã© apropriado. Algumas correÃ§Ãµes foram
necessÃ¡rias para garantir a execuÃ§Ã£o correta.

==================================================
ğŸ“Š CORREÃ‡ÃƒO AUTOMÃTICA â€” Q2: 70 pontos (mÃ¡x:75)
==================================================
QUESTAO_Q2: 70/75 - ImplementaÃ§Ã£o muito boa, com pequenas correÃ§Ãµes necessÃ¡rias para execuÃ§Ã£o
perfeita.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Este feedback foi gerado automaticamente por IA e pode
necessitar de revisÃ£o pelo professor.
